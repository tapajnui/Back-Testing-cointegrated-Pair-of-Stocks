# -*- coding: utf-8 -*-
"""Untitled

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sw2GqDKYHhLeIyNGxo2RzLsLhYnSXcRV

1. finding out all cointegrated pair
"""

import pandas as pd
import yfinance as yf
from statsmodels.tsa.stattools import coint
from itertools import combinations

# Get the stock prices for all the stocks in the list
stock_prices = pd.DataFrame()
cnt=0
stocks = ['ADANIENT.NS',
    'ADANIPORTS.NS',
    'APOLLOHOSP.NS',
    'ASIANPAINT.NS',
    'AXISBANK.NS',
    'BAJAJ-AUTO.NS',
    'BAJFINANCE.NS',
    'BAJAJFINSV.NS',
    'BPCL.NS',
    'BHARTIARTL.NS',
    'BRITANNIA.NS',
    'CIPLA.NS',
    'COALINDIA.NS',
    'DIVISLAB.NS',
    'DRREDDY.NS',
    'EICHERMOT.NS',
    'GRASIM.NS',
    'HCLTECH.NS',
    'HDFCBANK.NS',
    'HDFCLIFE.NS',
    'HEROMOTOCO.NS',
    'HINDALCO.NS',
    'HINDUNILVR.NS',
    'ICICIBANK.NS',
    'ITC.NS',
    'INDUSINDBK.NS',
    'INFY.NS',
    'JSWSTEEL.NS',
    'KOTAKBANK.NS',
    'LT.NS',
    'M&M.NS',
    'MARUTI.NS',
    'NTPC.NS',
    'NESTLEIND.NS',
    'ONGC.NS',
    'POWERGRID.NS',
    'RELIANCE.NS',
    'SBILIFE.NS',
    'SBIN.NS',
    'SUNPHARMA.NS',
    'TCS.NS',
    'TATACONSUM.NS',
    'TATAMOTORS.NS',
    'TATASTEEL.NS',
    'TECHM.NS',
    'TITAN.NS',
    'UPL.NS',
    'ULTRACEMCO.NS',
    'WIPRO.NS']

# Fetch stock data using yfinance and add to the DataFrame
for stock in stocks:
    stock_prices[stock] = yf.download(stock, start="1992-01-01", end="2023-01-01")["Adj Close"]

# Check for missing values
missing_values = stock_prices.isnull()

# Delete the rows with missing values
stock_prices = stock_prices.dropna(how="any")

# Calculate the cointegration test for all pairs of stocks
cointegration_results = {}
for stock_1, stock_2 in combinations(stock_prices.columns, 2):
    result = coint(stock_prices[stock_1], stock_prices[stock_2])
    if result[1] < 0.05:  # Check if p-value is less than 0.05
        cointegration_results[(stock_1, stock_2)] = result[1]
        cnt +=1

# Print the results of the cointegration tests
for stock_1, stock_2 in cointegration_results.keys():
    print(f"{stock_1} and {stock_2}")

print("count :", cnt)

"""4. backtesting of two cointegrated stock"""

import yfinance as yf
import numpy as np
from sklearn.linear_model import LinearRegression

# Define the stock symbols and the date range
stock_symbols = ['CIPLA.NS','BPCL.NS']
start_date = '1992-01-01'
end_date = '2023-08-01'

# Fetch stock data using yfinance
stock_data = yf.download(stock_symbols, start=start_date, end=end_date)['Close']

# Drop rows with missing values
stock_data.dropna(inplace=True)

# Extract adjusted closing prices
stock1 = stock_data['CIPLA.NS']
stock2 = stock_data['BPCL.NS']
#print("stock1 & stock 2:", stock1 , stock2)

# Create a linear regression model
model = LinearRegression()

# Reshape the data for regression
X = stock1.values.reshape(-1, 1)
y = stock2.values

# Fit the model
model.fit(X, y)

#making it of same value..................................................................................................
#stock1=stock1p*4
#stock2=stock2p

# Calculate residuals
residuals = y - model.predict(X)

# Calculate standard deviation of residuals
std_dev_residuals = np.std(residuals)

# Print results
print("Standard Deviation of Residuals:", std_dev_residuals)

# Backtesting Logic
capital=0
position_open = False
num_of_days = 0
pnl = 0
tpnl=0
p=0
q=0
lot_size_of_stock1=0
lot_size_of_stock2=0
start_date=0
end_date=0
cnt=0

for i in range(len(stock_data)):
    if not position_open:
        if residuals[i] <= -2*std_dev_residuals:  # Buy condition
            position_open = True

            lot_size_of_stock2= int(stock1[i])
            buy_price = stock2[i] *lot_size_of_stock2
            print("buying price of stock2 : ", buy_price)

            lot_size_of_stock1=int(stock2[i])
            sell_price = stock1[i]*lot_size_of_stock1
            print("selling price of stock1 : ", sell_price)
            fund_used= buy_price + sell_price
            print("fund used :", fund_used)

            q=1
            print(f"...Buying... Date: {stock_data.index[i]}")
            start_date= stock_data.index[i]

        if residuals[i] >= 2*std_dev_residuals:  # Short condition
            position_open = True
            lot_size_of_stock1=int(stock2[i])
            buy_price = stock1[i] * lot_size_of_stock1
            print("buying price of stock1 : ", buy_price)

            lot_size_of_stock2= int(stock1[i])
            sell_price = stock2[i]*lot_size_of_stock2
            print("selling price of stock2 : ", sell_price)
            fund_used= buy_price + sell_price
            print("fund used :", fund_used)

            p=1
            print(f"...Shorting... Date: {stock_data.index[i]}")
            start_date= stock_data.index[i]

    if position_open :
        if residuals[i] >= -std_dev_residuals and q==1 :
            position_open = False
            q=0
            cnt += 1
            sell_price = stock2[i]*lot_size_of_stock2
            print("selling price of stock2 :",sell_price)
            buy_price = stock1[i]*lot_size_of_stock1
            print("buying price of stock1 :",buy_price)
            pnl = (sell_price - buy_price)
            tpnl += (sell_price - buy_price)
            print(f"...Selling... Date: {stock_data.index[i]}")

            end_date = stock_data.index[i]
            num_of_days = (end_date - start_date).days
            roi=int((pnl/fund_used)*100)
            print("number of days :",num_of_days )
            print("p&l :", pnl)
            print("ROI : ", roi,"%")
            print("-----------------------------------------------------------------------------------------------------")

            # Square off condition

        if residuals[i] <= std_dev_residuals and p==1:
            position_open = False
            p=0
            cnt += 1
            sell_price = stock1[i]*lot_size_of_stock1
            print("selling price of stock1 :",sell_price)
            buy_price = stock2[i]*lot_size_of_stock2
            print("buying price of stock2 :",buy_price)
            pnl = (sell_price - buy_price)
            tpnl += (sell_price - buy_price)
            print(f"...Exiting Short...   Date: {stock_data.index[i]}")

            end_date = stock_data.index[i]
            num_of_days = (end_date - start_date).days
            roi=int((pnl/fund_used)*100)
            print("number of days :",num_of_days )
            print("p&l :", pnl)
            print("ROI : ", roi,"%")
            print("-----------------------------------------------------------------------------------------------------")

print("Total P&L:", tpnl)
print("Total number of trades :", cnt)

"""3. identifying dependent and indepndent pair"""

import yfinance as yf
import numpy as np
from sklearn.linear_model import LinearRegression

# Define the stock symbols and the date range
stock_symbols = ['BPCL.NS', 'CIPLA.NS']
start_date = '1992-01-01'
end_date = '2023-01-01'

# Fetch stock data using yfinance
stock_data = yf.download(stock_symbols, start=start_date, end=end_date)['Close']

# Calculate daily returns
returns = stock_data.pct_change().dropna()

# Initialize lists to store results
error_ratios = []
std_error_intercepts = []
std_error_residuals = []

# Loop through stock pairs
for i in range(len(stock_symbols)):
    for j in range(i + 1, len(stock_symbols)):
        # Define independent and dependent variables
        X = returns[stock_symbols[i]].values.reshape(-1, 1)
        y = returns[stock_symbols[j]].values

        # Create linear regression model
        model = LinearRegression()

        # Fit the model
        model.fit(X, y)

        # Calculate residuals and standard error of residuals
        residuals = y - model.predict(X)
        std_error_residual = np.std(residuals)

        # Calculate standard error of intercept
        std_error_intercept = std_error_residual * np.sqrt(np.mean(X ** 2))

        # Calculate error ratio
        error_ratio = std_error_intercept / std_error_residual

        # Append results to lists
        error_ratios.append(error_ratio)
        std_error_intercepts.append(std_error_intercept)
        std_error_residuals.append(std_error_residual)

# Find the minimum error ratio and corresponding indices
min_error_ratio = min(error_ratios)
min_error_ratio_index = error_ratios.index(min_error_ratio)

# Print the results for the stock pair with the minimum error ratio
stock_pair = (stock_symbols[min_error_ratio_index], stock_symbols[min_error_ratio_index + 1])
print(f"Regression {stock_pair[0]} on {stock_pair[1]}:")
print("Error Ratio:", min_error_ratio)
print(f"{stock_pair[0]} on {stock_pair[1]} has a lower error ratio.")

"""2. checking two pair are they truly cointegrated or not"""

import yfinance as yf
from statsmodels.tsa.stattools import coint

# Define the stock symbols and the date range
stock_symbols = ['SBIN.NS', 'ICICIBANK.NS']
start_date = '1992-01-01'
end_date = '2023-01-01'

# Fetch stock data using yfinance
stock_data = yf.download(stock_symbols, start=start_date, end=end_date)['Adj Close']

# Drop rows with missing values
stock_data.dropna(inplace=True)

# Perform cointegration test
result = coint(stock_data['SBIN.NS'], stock_data['ICICIBANK.NS'])

# Print cointegration test results
print("Cointegration Test Results:")
print("Cointegration Statistic:", result[0])
print("p-value:", result[1])
print("Critical Values:", result[2])
print("Null Hypothesis: The two series are not cointegrated.")

# Check if the p-value is less than the significance level (e.g., 0.05) to determine cointegration
if result[1] < 0.05:
    print("Conclusion: The two series are likely cointegrated.")
else:
    print("Conclusion: The two series are likely not cointegrated.")